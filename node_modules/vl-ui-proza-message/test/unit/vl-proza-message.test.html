<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-lite.js"></script>
  <script src="../../node_modules/web-component-tester/browser.js"></script>
  <script src="../../node_modules/sinon/pkg/sinon.js"></script>
  <script src="../../node_modules/sinon-chai/lib/sinon-chai.js"></script>

  <script type="module" src="../../vl-proza-message.src.js"></script>
</head>

<body>
  <test-fixture id="vl-proza-message-fixture">
    <template>
      <vl-proza-message id="message-1" data-vl-domain="foo" data-vl-code="bar"></vl-proza-message>
    </template>
  </test-fixture>

  <test-fixture id="vl-proza-messages-fixture">
    <template>
      <div>
        <vl-proza-message id="message-1" data-vl-domain="foo" data-vl-code="bar"></vl-proza-message>
        <vl-proza-message id="message-2" data-vl-domain="foo" data-vl-code="bar"></vl-proza-message>
      </div>
    </template>
  </test-fixture>

  <script type="module">
    import { VlProzaMessage, VlProzaMessagePreloader } from '../../vl-proza-message.src.js';
    import { awaitUntil } from 'vl-ui-core/vl-core';
    import fetchMock from 'fetch-mock/esm/client.mjs';

    suite('vl-proza-message', () => {
      const should = chai.should();
      const sandbox = sinon.createSandbox();

      setup((done) => {
        fetchMock.mock('proza/domein/foo/bar', { code: "bar", tekst: "foobar" });
        fetchMock.mock('proza/domein/foo/toegelatenoperaties', { update: true });

        customElements.whenDefined('vl-proza-message').then(() => done());
      });

      teardown(() => {
        sandbox.restore();
        fetchMock.restore();
        delete VlProzaMessage.__cache;
        delete VlProzaMessagePreloader.__cache;
      });

      function prozaMessageContent(message) {
        return prozaWysiwygElement(message).textContent;
      }

      function prozaMessageEditButton(message) {
        return message.shadowRoot.querySelector('button');
      }

      function prozaMessageEditButtonIcon(button) {
        return button.querySelector('[is="vl-icon"]').getAttribute('icon');
      }

      function prozaWysiwygElement(message) {
        return message.querySelector('#wysiwyg');
      }

      function prozaTypographyElement(message) {
        return message.querySelector('vl-typography');
      }

      test('toont een bericht', () => {
        const proza = fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          return awaitUntil(() => {
            return prozaMessageContent(proza.querySelector('#message-1')) === 'foobar' &&
                    prozaMessageContent(proza.querySelector('#message-2')) === 'foobar';
          });
        });
      });

      test('bevat de mogelijkheid om de content te wijzigen indien de wijzig operatie toegelaten is', () => {
        const proza = fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          const button1 = prozaMessageEditButton(proza.querySelector('#message-1'));
          const icon1 = prozaMessageEditButtonIcon(button1);
          should.exist(button1);
          icon1.should.equal('edit');

          const button2 = prozaMessageEditButton(proza.querySelector('#message-2'));
          const icon2 = prozaMessageEditButtonIcon(button2);
          should.exist(button2);
          icon2.should.equal('edit');
        });
      });

      test('bevat niet de mogelijkheid om de content te wijzigen indien de wijzig operatie niet toegelaten is', () => {
        fetchMock.mock('proza/domein/foo/toegelatenoperaties', { update: false }, { overwriteRoutes: true });

        const proza = fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          should.not.exist(prozaMessageEditButton(proza.querySelector('#message-1')));
          should.not.exist(prozaMessageEditButton(proza.querySelector('#message-2')));
        });
      });

      test('er wordt een error gelogd indien er iets fout loopt bij het ophalen van een proza bericht', () => {
        sandbox.spy(console, 'error');
        fetchMock.mock('proza/domein/foo/bar', 404, { overwriteRoutes: true });

        const proza = fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          prozaMessageContent(proza.querySelector('#message-1')).should.equal('');
          prozaMessageContent(proza.querySelector('#message-2')).should.equal('');
          console.error.should.be.called;
        });
      });

      test('er wordt een error gelogd indien er iets fout loopt bij het ophalen van de toegelaten operaties', () => {
        sandbox.spy(console, 'error');
        fetchMock.mock('proza/domein/foo/toegelatenoperaties', 404, { overwriteRoutes: true });

        const proza = fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          should.not.exist(prozaMessageEditButton(proza.querySelector('#message-1')));
          should.not.exist(prozaMessageEditButton(proza.querySelector('#message-2')));
          console.error.should.be.called;
        });
      });

      test('haalt het bericht en de toegelaten operaties maar 1 keer op indien deze al in de cache zitten', () => {
        fixture('vl-proza-messages-fixture');
        return fetchMock.flush(true).then(() => {
          fetchMock.calls('proza/domein/foo/bar').length.should.equal(1);
          fetchMock.calls('proza/domein/foo/toegelatenoperaties').length.should.equal(1);
        });
      });

      test('het aanpassen van het data-vl-code attribuut zal ervoor zorgen dat het bericht voor die code getoond wordt', () => {
        fetchMock.mock('proza/domein/foo/foo', { code: "foo", tekst: "foofoo" });

        const proza = fixture('vl-proza-messages-fixture');
        const message1 = proza.querySelector('#message-1');
        message1.dataset.vlCode = 'foo';
        return fetchMock.flush(true).then(() => {
          return awaitUntil(() => {
            return prozaMessageContent(proza.querySelector('#message-1')) === 'foofoo';
          });
        });
      });

      test('het aanpassen van het data-vl-domain attribuut zal ervoor zorgen dat het bericht voor dat domein getoond wordt', () => {
        fetchMock.mock('proza/domein/bar/bar', { code: "bar", tekst: "barbar" });

        const proza = fixture('vl-proza-messages-fixture');
        const message1 = proza.querySelector('#message-1');
        message1.dataset.vlDomain = 'bar';
        return fetchMock.flush(true).then(() => {
          return awaitUntil(() => {
            return prozaMessageContent(proza.querySelector('#message-1')) === 'barbar';
          });
        });
      });

      test('bevat een bereikbaar wysiwyg element met eigen stijl dat door TinyMCE gebruikt kan worden', () => {
        const message = fixture('vl-proza-message-fixture');
        const wysiwyg = prozaWysiwygElement(message);
        should.exist(wysiwyg);
        wysiwyg.style.should.not.be.undefined;
      });

      test('zodra een proza domein code opgehaald werd zal het wysiwyg element in lees modus verplaatst worden naar een vl-typography element zodat de wysiwyg stijl toegepast wordt', () => {
        const message = fixture('vl-proza-message-fixture');
        let typography = prozaTypographyElement(message);
        should.not.exist(typography);
        return fetchMock.flush(true).then(() => {
          typography = prozaTypographyElement(message);
          const wysiwyg = prozaWysiwygElement(typography);
          should.exist(typography);
          should.exist(wysiwyg);
        });
      });

      test('zodra de bewerk modus geactiveerd wordt zal het wysiwyg element verplaatst worden zodat het door TinyMCE gebruikt kan worden', () => {
        const message = fixture('vl-proza-message-fixture');
        let typography = prozaTypographyElement(message);
        let wysiwyg = prozaWysiwygElement(message);
        should.not.exist(typography);
        should.exist(wysiwyg);
        return fetchMock.flush(true).then(() => {
          typography = prozaTypographyElement(message);
          wysiwyg = prozaWysiwygElement(typography);
          should.exist(typography);
          should.exist(wysiwyg);
          prozaMessageEditButton(message).click();
          typography = prozaTypographyElement(message);
          wysiwyg = prozaWysiwygElement(message);
          should.not.exist(typography);
          should.exist(wysiwyg);
        });
      });

      test('bij het klikken op de bewerk knop zal de bewerk modus geactiveerd worden', () => {
        sandbox.spy(tinyMCE, 'init');
        const message = fixture('vl-proza-message-fixture');
        return fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          assert(tinyMCE.init.called);
        });
      });

      test('bij het klikken op de bewerk knop zal na het activeren van de bewerk modus de bewerk knop verwijderd worden', (done) => {
        sandbox.spy(tinyMCE, 'init');
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            prozaMessageEditButton(message).hidden.should.to.be.true
            editor.destroy();
            done();
          });
        });
      });

      test('bij het klikken op de bewerk knop krijgt de geactiveerde wysiwyg focus', (done) => {
        sandbox.spy(tinyMCE, 'init');
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          sandbox.spy(editor, 'focus');
          editor.on('init', () => {
            assert(editor.focus.called);
            editor.destroy();
            done();
          });
        });
      });

      test('bij het klikken op de bewerk knop krijgt de geactiveerde wysiwyg de typography class zodat in de bewerk modus zodat de wysiwyg stijl toegepast wordt', (done) => {
        sandbox.spy(tinyMCE, 'init');
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            const wysiwyg = prozaWysiwygElement(message);
            wysiwyg.classList.contains('vl-typography').should.to.be.true;
            editor.destroy();
            done();
          });
        });
      });

      test('een escape toets zal de bewerk modus deactiveren en de wijzigingen ongedaan maken', (done) => {
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            sandbox.spy(editor, 'destroy');
            const hasUndoStub = sandbox.stub(editor.undoManager, 'hasUndo');
            hasUndoStub.onCall(0).returns(true);
            hasUndoStub.onCall(1).returns(true);
            hasUndoStub.onCall(2).returns(false);
            sandbox.spy(editor.undoManager, 'undo');
            editor.on('keydown', () => {
              assert(editor.destroy.called);
              assert(editor.undoManager.undo.calledTwice);
              done();
            });
            editor.fire('keydown', {
              keyCode: 27
            });
          });
        });
      });

      test('een enter toets zal de bewerk modus deactiveren en de enter wijziging ongedaan maken', (done) => {
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            sandbox.spy(editor, 'destroy');
            sandbox.spy(editor.undoManager, 'undo');
            editor.on('keydown', () => {
              assert(editor.destroy.called);
              assert(editor.undoManager.undo.calledOnce);
              done();
            });
            editor.fire('keydown', {
              keyCode: 13
            });
          });
        });
      });

      test('een enter toets in combinatie met de shift toets zal de bewerk modus niet deactiveren', (done) => {
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            sandbox.spy(editor, 'destroy');
            editor.on('keydown', () => {
              assert(editor.destroy.notCalled);
              editor.destroy();
              done();
            });
            editor.fire('keydown', {
              keyCode: 13,
              shiftKey: true
            });
          });
        });
      });

      test('een wysiwyg blur zal de bewerk modus deactiveren', (done) => {
        const message = fixture('vl-proza-message-fixture');
        fetchMock.flush(true).then(() => {
          prozaMessageEditButton(message).click();
          const editor = tinyMCE.activeEditor;
          editor.on('init', () => {
            sandbox.spy(editor, 'destroy');
            editor.on('blur', () => {
              assert(editor.destroy.called);
              done();
            });
            editor.fire('blur');
          });
        });
      });
    });
  </script>
</body>

</html>